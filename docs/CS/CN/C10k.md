## Introduction

The C10k problem is the problem of optimizing network sockets to handle a large number of clients at the same time.
The name C10k is a numeronym for concurrently handling ten thousand connections.
Handling many concurrent connections is a different problem from handling many requests per second: the latter requires high throughput (processing them quickly), 
while the former does not have to be fast, but requires efficient scheduling of connections.

c10k解决的是1w连接的高效调度处理问题，而非请求吞吐量问题


要让服务支持大量客户端连接，受到操作系统、服务本身实现等的多种限制：

- 操作系统
  - 允许进程打开的最大fd数量，通常较小，需通过ulimit -n设置
  - 默认进程、线程栈大小，偏大且进程数、线程数多的话，容易OOM
  - 那个时代有些可观存在的限制：
    - glibc2.1以下版本使用16-bit数字记录句柄数，仅支持32767个
    - 有的系统使用16位记录进程ID、现成ID，so可能创建不了太多进程、线程
    - 有的系统预分配了太大的thread-local存储，比如1MB，假设虚地址空间2GB，那么最多创建2000个线程
  - 内核本身存在问题
    - select、poll、epoll的改进
    - thundering herd（惊群）问题
- 服务实现
  - 网络IO管理机制，同步、异步
  - 服务采用的并发处理模型（ppc、tpc、cpc）
  - 框架实现
    - zero-copy问题，了解收一个网络包的旅程，从网卡端口、驱动中buffer、内核协议栈、应用程序缓冲区，可借助系统调用来减少拷贝开销，推荐常见的零拷贝技术
    - 使用writev避免发送小包，writev+iovec（scatter、gather分散读、聚集写）
    - 使用TCP_CORK避免发送小包，将多个小包合并达到MSS后发送, see TCP_CORK
    - 过载保护机制，过载时拒绝新连接，降低错误率。如使用IO ready的客户端数量来作为负载评估指标
  - caching技术
- 硬件能力
  - CPU
  - 内存
  - 网卡

Linux下通过epoll可以实现同步非阻塞IO，实现高效地IO事件处理

packet scaling：内核提供的收包机制太重了，自定义网卡驱动，接管对网卡的管理，将收到的包直接递交给应用程序缓冲区，而不是传给内核协议栈，像这样的实现包括：

PF_RING
Netmap
Intel DPDK
ps：现在有了一种相比较之下更好的技术，基于eBPF的高性能网络。

multi-core scaling

spinlock,mutex,critical section,semaphores?

no waiting
un-synchonization
core local data
ring buffers
RCU (read-copy-update)
atomics
cmpxchg
lock add
lockfree data structures
thread models
pipeline
worker
taskset
thread affinity
CPU and memory

co-locate data

don’t: data structures all over memory connected via pointers

do: all the data together in one chunk of memory

ps：每次follow一个pointer都是一个cache miss，考虑访存延迟! 假设你的数据是A->B->C->D，4个cache miss，如过组织成A|B|C|D，那么就可以减少到4次cache miss。

compress data

bit-fields instead of large integers
indexes (1, 2 bytes) instead of pointers (8 bytes)
get rid of padding in data structures
cache efficient data structures

B+ tree over Binary Search Tree, etc. 减少访存次数

NUMA

double the main memory access time

memory pools

per object
per thread
per socket
defend against resource exhaustion
hyper-threading

threads > cores, 一个thread阻塞了其他thread可以继续跑，充分利用cpu

linux bootparam

hugepages




## c10m



The c10m problem! 依靠内核是不能胜任这个问题的，内核恰恰是问题所在

> [c10m: defending the Internet at scale](https://www.youtube.com/watch?v=73XNtI0w7jA)





## Links



## References

1. [The C10K problem](http://www.kegel.com/c10k.html)
2. https://www.hitzhangjie.pro/blog/2024-01-06-%E8%A7%A3%E5%86%B3c10kc100kc10m%E9%97%AE%E9%A2%98/