



### Data Type

#### Basic Type

任何一门语言都有对应的基础类型， Go 语言也有自己丰富的基础类型，常用的有：整型、浮点数、布尔型和字符串


在 Go 语言中，整型分为：
- 有符号整型：如 int、int8、int16、int32 和 int64。
- 无符号整型：如 uint、uint8、uint16、uint32 和 uint64。

除了有用位（bit）大小表示的整型外，还有 int 和 uint 这两个没有具体 bit 大小的整型，它们的大小可能是 32bit，也可能是 64bit，和硬件设备 CPU 有关
在整型中，如果能确定 int 的 bit 就选择比较明确的 int 类型，因为这会让你的程序具备很好的移植性

在 Go 语言中，还有一种字节类型 byte，它其实等价于 uint8 类型，可以理解为 uint8 类型的别名，用于定义一个字节，所以字节 byte 类型也属于整型

浮点数
浮点数就代表现实中的小数。Go 语言提供了两种精度的浮点数，分别是 float32 和 float64。项目中最常用的是 float64，因为它的精度高，浮点计算的结果相比 float32 误差会更小

布尔型
一个布尔型的值只有两种：true 和 false Go 语言中的布尔型使用关键字 bool 定义

#### strings

其中关于string的描述位于src/builtin/builtin.go

- string是8比特字节的集合，通常但并不一定是UTF-8编码的文本。
- string可以为空（长度为0），但不会是nil；
- string对象不可以修改。

```go
// string is the set of all strings of 8-bit bytes, conventionally but not
// necessarily representing UTF-8-encoded text. A string may be empty, but
// not nil. Values of string type are immutable.
type string string
```

`src/runtime/string.go:stringStruct` 定义了string的数据结构：

```go
type stringStruct struct {
    str unsafe.Pointer
    len int
}
```

string数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片，准确的说是byte切片经常发生转换
byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存
字符串 string 也是一个不可变的字节序列，所以可以直接转为字节切片 []byte


字符串常量在词法解析阶段最终会被标记成StringLit类型的Token并被传递到编译的下一个阶段。
在语法分析阶段，采取递归下降的方式读取Uft-8字符，单撇号或双引号是字符串的标识。分析的逻辑位于syntax/scanner.go文件中

如果在代码中识别到单撇号，则调用rawString函数；如果识别到双引号，则调用stdString函数，两者的处理略有不同。
对于单撇号的处理比较简单：一直循环向后读取，直到寻找到配对的单撇号，
双引号调用stdString函数，如果出现另一个双引号则直接退出；如果出现了\\，则对后面的字符进行转义

string（s.stopLit（））将解析到的字节转换为字符串，这种转换会在字符串左、右两边加上双引号，因此"hello"会被解析为""hello"
在抽象语法树阶段，无论是import语句中包的路径、结构体中的字段标签还是字符串常量，都会调用strconv.Unquote（s）去掉字符串两边的引号等干扰，还原其本来的面目

字符常量存储于静态存储区，其内容不可以被改变，声明时有单撇号和双引号两种方法。字符常量的拼接发生在编译时，而字符串变量的拼接发生在运行时

运行时字符串的拼接并不是简单地将一个字符串合并到另一个字符串中，而是找到一个更大的空间，并通过内存复制的形式将字符串复制到其中
无论使用concatstring{2，3，4，5}函数中的哪一个，最终都会调用runtime.concatstrings函数
concatstrings函数会先对传入的切片参数进行遍历，过滤空字符串并计算拼接后字符串的长度
拼接的过程位于rawstringtmp函数中，当拼接后的字符串小于32字节时，会有一个临时的缓存供其使用。
当拼接后的字符串大于32字节时，堆区会开辟一个足够大的内存空间，并将多个字符串存入其中，期间会涉及内存的复制（copy）

string和[]byte都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要跟据实际应用场景来选择。

string 擅长的场景：

- 需要字符串比较的场景；
- 不需要nil字符串的场景；

[]byte擅长的场景：

- 修改字符串的场景，尤其是修改粒度为1个字节；
- 函数返回值，需要用nil表示含义的场景；
- 需要切片操作的场景；

虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中[]byte使用更多



Go语言中数组、字符串和切片三者是密切相关的数据结构。

这三种数据类型，在底层原始数据有着相同的内存结构，在上层，因为语法的限制而有着不同的行为表现。

- 首先，Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的。
- Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改。字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制。
- 切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。

> [!TIP]
>
>  其实Go语言的赋值和函数传参规则很简单，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理

#### default value

零值其实就是一个变量的默认值，在 Go 语言中，如果我们声明了一个变量，但是没有对其进行初始化，那么 Go 语言会自动初始化其值为对应类型的零值。比如数字类的零值是 0，布尔型的零值是 false，字符串的零值是  空字符串等

#### Reference Type

引用类型(reference type)特指slice、map、channel这三种预定义类型

类型转换

Go 语言是强类型的语言，也就是说不同类型的变量是无法相互使用和计算的，这也是为了保证Go 程序的健壮性，所以不同类型的变量在进行赋值或者计算前，需要先进行类型转换

通过包 strconv 的 Itoa 函数可以把一个 int 类型转为 string，Atoi 函数则用来把 string 转为 int。
同理对于浮点数、布尔型，Go 语言提供了 strconv.ParseFloat、strconv.ParseBool、strconv.FormatFloat 和 strconv.FormatBool 进行互转

对于数字类型之间，可以通过强制转换的方式
这种使用方式比简单，采用类型（要转换的变量）格式即可。采用强制转换的方式转换数字类型，可能会丢失一些精度，比如浮点型转为整型时，小数点部分会全部丢失



#### struct

结构体定义

```go
type structName struct{
    fieldName typeName
    ....
    ....
}
```

空结构体

Pointers to distinct zero-size variables may or may not be equal
不论逃逸还是未逃逸，我们都不应该对空结构体类型变量指向的内存地址是否一样，做任何预期。由于空结构体占用的空间大小为零，我们可以利用这个特性，完成一些功能，却不需要占用额外空间




#### Interface

在接口的实现中，值类型接收者和指针类型接收者不一样 以指针类型接收者实现接口的时候，只有对应的指针类型才被认为实现了该接口
可以这样解读：

- 当值类型作为接收者时，person 类型和*person类型都实现了该接口。
- 当指针类型作为接收者时，只有*person类型实现了该接口。

在 Go 语言中没有继承的概念，所以结构、接口之间也没有父子关系，Go 语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活

直接把结构体类型放进来，就是组合，不需要字段名。组合后，被组合的 address 称为内部类型，person 称为外部类型。修改了 person 结构体后，声明和使用也需要一起修改
类型组合后，外部类型不仅可以使用内部类型的字段，也可以使用内部类型的方法，就像使用自己的方法一样。如果外部类型定义了和内部类型同样的方法，那么外部类型的会覆盖内部类型，这就是方法的覆写
方法覆写不会影响内部类型的方法实现。

有了接口和实现接口的类型，就会有类型断言。类型断言用来判断一个接口的值是否是实现该接口的某个具体类型。



#### function



Go 的函数可以返回多个值
