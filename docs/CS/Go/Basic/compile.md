## Introduction



code in `src/cmd/compile/internal/`

- Lexical Analysis
- Syntax Analysis
- generate Abstract Syntax Tree
- type check
- relationship
- inline method
- escape analysis
- closure override
- iterate method
- generate SSA
- generate machine code



compiler不允许出现未使用的变量和导入包

## Lexical Analysis

扫描文件将其token化 例如 操作符 +/- -> _IncOp, 赋值符:= -> _Define

标准库里go/scanner go/token提供了接口用于扫描源代码

## Syntax Analysis

Go语言采用了标准的自上而下的递归下降（Top-Down Recursive-Descent）算法，以简单高效的方式完成无须回溯的语法扫描，核心算法位于syntax/nodes.go及syntax/parser.go中

源文件中的每一种声明都有对应的语法，递归下降通过识别初始的标识符，例如_const，采用对应的语法进行解析
这种方式能够较快地解析并识别可能出现的语法错误。每一种声明语法在Go语言规范中都有定义



逃逸分析是Go语言中重要的优化阶段，用于标识变量内存应该被分配在栈区还是堆区。
在传统的C或C++语言中，开发者经常会犯的错误是函数返回了一个栈上的对象指针，在函数执行完成，栈被销毁后，继续访问被销毁栈上的对象指针，导致出现问题。
Go语言能够通过编译时的逃逸分析识别这种问题，自动将该变量放置到堆区，并借助Go运行时的垃圾回收机制自动释放内存。编译器会尽可能地将变量放置到栈中，
因为栈中的对象随着函数调用结束会被自动销毁，减轻运行时分配和垃圾回收的负担

在Go语言中，开发者模糊了栈区与堆区的差别，不管是字符串、数组字面量，还是通过new、make标识符创建的对象，都既可能被分配到栈中，也可能被分配到堆中
分配时，遵循以下两个原则
- 原则1：指向栈上对象的指针不能被存储到堆中
- 原则2：指向栈上对象的指针不能超过该栈对象的生命周期

Go语言通过对抽象语法树的静态数据流分析（static data-flow analysis）来实现逃逸分析，这种方式构建了带权重的有向图


## AST

在Go语言源文件中的任何一种import、type、const、func声明都是一个根节点，在根节点下包含当前声明的子节点。
如下decls函数将源文件中的所有声明语句转换为节点（Node）数组。核心逻辑位于gc/noder.go中
每个节点都包含了当前节点属性的Op字段，定义在gc/syntax.go中，以O开头。与词法解析阶段中的token相同的是，Op字段也是一个整数。不同的是，每个Op字段都包含了语义信息



闭包变量捕获的核心逻辑位于gc/closure.go的capturevars函数中 


函数内联指将较小的函数直接组合进调用者的函数。这是现代编译器优化的一种核心技术。函数内联的优势在于，可以减少函数调用带来的开销。
对于Go语言来说，函数调用的成本在于参数与返回值栈复制、较小的栈寄存器开销以及函数序言部分的检查栈扩容（Go语言中的栈是可以动态扩容的）
同时，函数内联是其他编译器优化（例如无效代码消除）的基础。我们可以通过一段简单的程序衡量函数内联带来的效率提升[3]
，如下所示，使用bench对max函数调用进行测试。当我们在函数的注释前方加上//go：noinline时，代表当前函数是禁止进行函数内联优化的。取消该注释后，max函数将会对其进行内联优化

Go语言编译器会计算函数内联花费的成本，只有执行相对简单的函数时才会内联。函数内联的核心逻辑位于gc/inl.go中。当函数内部有for、range、go、select等语句时，该函数不会被内联，当函数执行过于复杂（例如太多的语句或者函数为递归函数）时，也不会执行内

如果希望程序中所有的函数都不执行内联操作，那么可以添加编译器选项-l 
在调试时，可以获取当前函数是否可以内联，以及不可以内联的原因 

## escape

逃逸分析是Go语言中重要的优化阶段，用于标识变量内存应该被分配在栈区还是堆区。
在传统的C或C++语言中，开发者经常会犯的错误是函数返回了一个栈上的对象指针，在函数执行完成，栈被销毁后，继续访问被销毁栈上的对象指针，导致出现问题。
Go语言能够通过编译时的逃逸分析识别这种问题，自动将该变量放置到堆区，并借助Go运行时的垃圾回收机制自动释放内存。
编译器会尽可能地将变量放置到栈中，因为栈中的对象随着函数调用结束会被自动销毁，减轻运行时分配和垃圾回收的负担。
在Go语言中，开发者模糊了栈区与堆区的差别，不管是字符串、数组字面量，还是通过new、make标识符创建的对象，都既可能被分配到栈中，也可能被分配到堆中。
分配时，遵循以下两个原则：
- 原则1：指向栈上对象的指针不能被存储到堆中
- 原则2：指向栈上对象的指针不能超过该栈对象的生命周期

Go语言通过对抽象语法树的静态数据流分析（static data-flow analysis）来实现逃逸分析，这种方式构建了带权重的有向图。 



在前面的阶段，编译器完成了闭包变量的捕获用于决定是通过指针引用还是值引用的方式传递外部变量。
在完成逃逸分析后，下一个优化的阶段为闭包重写，其核心逻辑位于gc/closure.go中。
闭包重写分为闭包定义后被立即调用和闭包定义后不被立即调用两种情况。在闭包被立即调用的情况下，闭包只能被调用一次，这时可以将闭包转换为普通函数的调用形式。
如果闭包定义后不被立即调用，而是后续调用，那么同一个闭包可能被调用多次，这时需要创建闭包对象。
如果变量是按值引用的，并且该变量占用的存储空间小于2×sizeof（int），那么通过在函数体内创建局部变量的形式来产生该变量。
如果变量通过指针或值引用，但是占用存储空间较大，那么捕获的变量（var）转换成指针类型的&var。这两种方式都需要在函数序言阶段将变量初始化为捕获变量的值


闭包重写后，需要遍历函数，其逻辑在gc/walk.go文件的walk函数中。
在该阶段会识别出声明但是并未被使用的变量，遍历函数中的声明和表达式，将某些代表操作的节点转换为运行时的具体函数执行。
例如，获取map中的值会被转换为运行时mapaccess2_fast64函数（详见第8章）。



在执行walk函数遍历之前，编译器还需要对某些表达式和语句进行重新排序，例如将x/=y替换为x=x/y。
根据需要引入临时变量，以确保形式简单，例如x=m[k]或m[k]=x，而k可以寻址。



## SSA

SSA生成阶段是编译器进行后续优化的保证，例如常量传播（Constant Propagation）、无效代码清除、消除冗余、强度降低（Strength Reduction）等。
大部分与SSA相关的代码位于ssa/文件夹中，但是将抽象语法树转换为SSA的逻辑位于gc/ssa.go文件中。在ssa/README.md文件中，有对SSA生成阶段比较详细的描述。
Go语言提供了强有力的工具查看SSA初始及其后续优化阶段生成的代码片段，可以通过在编译时指定GOSSAFUNC=main实现



## Links


## References

