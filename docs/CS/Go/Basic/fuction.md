## Introduction





### Function

```go
func funcName(params) result {
    body
}
```

如果函数有多个返回值，返回值部分的类型定义需要使用小括号括起来
在函数体中，可以使用 return 返回多个值，返回的多个值通过逗号分隔即可，返回多个值的类型顺序要和函数声明的返回类型顺序一致
不止函数的参数可以有变量名称，函数的返回值也可以，也就是说你可以为每个返回值都起一个名字，这个名字可以像参数一样在函数体内使用
虽然 Go 语言支持函数返回值命名，但是并不是太常用，根据自己的需求情况，酌情选择是否对函数返回值命名

可变参数

定义可变参数，只要在参数类型前加三个点 … 即可
可变参数的类型其实就是切片
如果你定义的函数中既有普通参数，又有可变参数，那么可变参数一定要放在参数列表的最后一个

同一个包中的函数哪怕是私有的（函数名称首字母小写）也可以被调用。如果不同包的函数要被调用，那么函数的作用域必须是公有的，也就是函数名称的首字母要大写，比如 Println


Go 语言没有用 public、private 这样的修饰符来修饰函数是公有还是私有，而是通过函数名称的大小写来代表，这样省略了烦琐的修饰符，更简洁

1. 函数名称首字母小写代表私有函数，只有在同一个包中才可以被调用；
2. 函数名称首字母大写代表公有函数，不同的包也可以调用；
3. 任何一个函数都会从属于一个包。



#### Function Value

当把一个函数赋值给某个变量后，这个变量就被称为Function Value

C语言中的函数指针就是个函数地址。函数指针的类型类 似于函数声明，编译器参考这种类型信息并依据调用约定来生成传参等汇编指令

定Function Value确实是个指针，而且是个两级指针。 Function Value不直接指向目标函数，而是一个目标函数的指针

Go语言在设计上用这种两级指针结构将函数指针和闭包统一为Function Value，运行阶段调用者不 需要关心调用的函数是个普通的函数还是个闭包函数，一致对待就可以了



对于不构成闭包的Function Value, 第二层的指针是编译阶段静态分配的



#### Closure

匿名函数和闭包
顾名思义，匿名函数就是没有名字的函数，这是它和正常函数的主要区别

有了匿名函数，就可以在函数中再定义函数（函数嵌套），定义的这个匿名函数，也可以称为内部函数。更重要的是，在函数内定义的内部函数，可以使用外部函数的变量等，这种方式也称为闭包


```go
func main() {
    cl:=colsure()
    fmt.Println(cl())
    fmt.Println(cl())
    fmt.Println(cl())
}

func colsure() func() int {
    i:=0
    return func() int {
        i++
        return i
    }
}
```

运行这个代码，你会看到输出打印的结果是：1 2 3
这都得益于匿名函数闭包的能力，让我们自定义的 colsure 函数，可以返回一个匿名函数，并且持有外部函数 colsure 的变量 i。因而在 main 函数中，每调用一次 cl()，i 的值就会加 1。
小提示：在 Go 语言中，函数也是一种类型，它也可以被用来声明函数类型的变量、参数或者作为另一个函数的返回值类型。



Go会在运行时通过runtime.newobject()动态分配Closure对象



#### Method

在 Go 语言中，方法和函数是两个概念，但又非常相似，不同点在于方法必须要有一个接收者，这个接收者是一个类型，这样方法就和这个类型绑定在一起，称为这个类型的方法。
虽然存在函数和方法两个概念，但是它们基本相同，不同的是所属的对象。函数属于一个包，方法属于一个类型，所以方法也可以简单地理解为和一个类型关联的函数。

接收者的定义和普通变量、函数参数等一样，前面是变量名，后面是接收者类型。
定义了接收者的方法后，就可以通过点操作符调用方法

接收者就是函数和方法的最大不同，此外，上面所讲到的函数具备的能力，方法也都具备。
方法的接收者除了可以是值类型，也可以是指针类型。
定义的方法的接收者类型是指针，所以我们对指针的修改是有效的，如果不是指针，修改就没有效果
在调用方法的时候，传递的接收者本质上都是副本，只不过一个是这个值副本，一是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。我们可以简单地理解为值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法

```go
func main()	{
age := Age(25)
	age.String()
	age.Modify()
	age.String()
}

func (age *Age) Modify() {
	*age = Age(30)
}

type Age uint

func (age Age) String() {
	fmt.Println("the age is", age)
}
```

示例中调用指针接收者方法的时候，使用的是一个值类型的变量，并不是一个指针类型，其实这里使用指针变量调用也是可以的，如下面的代码所示

```go
(&age).Modify()
```

这就是 Go 语言编译器帮我们自动做的事情：

- 如果使用一个值类型变量调用指针类型接收者的方法，Go 语言编译器会自动帮我们取指针调用，以满足指针接收者的要求。
- 同样的原理，如果使用一个指针类型变量调用值类型接收者的方法，Go 语言编译器会自动帮我们解引用调用，以满足值类型接收者的要求。

总之，方法的调用者，既可以是值也可以是指针，不用太关注这些，Go 语言会帮我们自动转义，大大提高开发效率，同时避免因不小心造成的 Bug。
不管是使用值类型接收者，还是指针类型接收者，要先确定你的需求：在对类型进行操作的时候是要改变当前接收者的值，还是要创建一个新值进行返回？这些就可以决定使用哪种接收者





## Links

