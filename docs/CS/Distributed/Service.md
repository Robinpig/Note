## Introduction





## 注册中心

服务发现是⼀个古老的话题， 当应用开始脱离单机运行和访问时， 服务发现就诞生了。 目前的网络架构是每个主机都有⼀个独立的 IP 地址， 那么服务发现基本上都是通过某种方式获取到服务所部署的 IP 地址。
DNS 协议是最早将⼀个网络名称翻译为网络 IP 的协议， 在最初的架构选型中，DNS+LVS+Nginx 基本可以满足所有的 RESTful 服务的发现， 此时服务的 IP 列表通常配置在 nginx或者 LVS。
后来出现了 RPC 服务， 服务的上下线更加频繁， 人们开始寻求⼀种能够支持动态上下线并且推送 IP 列表变化的注册中心产品。  

Zookeeper 是⼀款经典的服务注册中心产品（虽然它最初的定位并不在于此） ， 在很长⼀段时间里，它是国人在提起 RPC 服务注册中心时心里想到的唯⼀选择， 这很大程度上与 Dubbo 在中国的普及程度有关。 
Consul 和 Eureka 都出现于 2014 年， Consul 在设计上把很多分布式服务治理上要用到的功能都包含在内， 可以支持服务注册、 健康检查、 配置管理、 Service Mesh 等。 
Eureka则借着微服务概念的流行， 与 SpringCloud 生态的深度结合， 也获取了大量的用户  
Nacos则携带着阿里巴巴大规模服务生产经验， 试图在服务注册和配置管理这个市场上， 提供给
用户⼀个新的选择。  

注册中心的核心数据是服务的名字和它对应的网络地址， 当服务注册了多个实例时， 我们需要对不健康的实例进行过滤或者针对实例的⼀些特征进行流量的分配， 那么就需要在实例上存储⼀些例如健康状态、 权重等属性。
 随着服务规模的扩大， 渐渐的又需要在整个服务级别设定⼀些权限规则、以及对所有实例都生效的⼀些开关， 于是在服务级别又会设立⼀些属性。 
再往后， 我们又发现单个服务的实例又会有划分为多个子集的需求， 例如⼀个服务是多机房部署的， 那么可能需要对每个机房的实例做不同的配置， 这样又需要在服务和实例之间再设定⼀个数据级别。  



Zookeeper 没有针对服务发现设计数据模型， 它的数据是以⼀种更加抽象的树形 K-V 组织的， 因此理论上可以存储任何语义的数据。 
而 Eureka 或者 Consul 都是做到了实例级别的数据扩展， 这可以满足大部分的场景， 不过无法满足大规模和多环境的服务数据存储。  
Nacos 在经过内部多年生产经验后提炼出的数据模型， 则是⼀种服务-集群-实例的三层模型。   
Nacos 的数据模型虽然相对复杂， 但是它并不强制你使用它里面的所有数据， 在大多数场景下， 你可以选择忽略这些数据属性， 此时可以降维成和 Eureka 和 Consul ⼀样的数据模型。  



另外⼀个需要考虑的是数据的隔离模型， 作为⼀个共享服务型的组件， 需要能够在多个用户或者业
务方使用的情况下， 保证数据的隔离和安全， 这在稍微大⼀点的业务场景中非常常见。 另⼀方面服
务注册中心往往会支持云上部署， 此时就要求服务注册中心的数据模型能够适配云上的通用模型。
Zookeeper、 Consul 和 Eureka 在开源层面都没有很明确的针对服务隔离的模型， Nacos 则在⼀开始就考虑到如何让用户能够以多种维度进行数据隔离， 同时能够平滑的迁移到阿里云上对应的商业化产品。  



临时实例和持久化实例。 在定义上区分临时实例和持久化
实例的关键是健康检查的方式。 临时实例使用客户端上报模式， 而持久化实例使用服务端反向探测模式。 
临时实例需要能够自动摘除不健康实例， 而且无需持久化存储实例， 那么这种实例就适用于类 Gossip 的协议。
右边的持久化实例使用服务端探测的健康检查方式， 因为客户端不会上报心跳，那么自然就不能去自动摘除下线的实例  

在大中型的公司里， 这两种类型的服务往往都有。 ⼀些基础的组件例如数据库、 缓存等， 这些往往不能上报心跳， 这种类型的服务在注册时， 就需要作为持久化实例注册。 
而上层的业务服务， 例如微服务或者 Dubbo 服务， 服务的 Provider 端支持添加汇报心跳的逻辑， 此时就可以使用动态服务的注册方式。  



临时实例和持久实例的区分应该在service level, 一个service只能是其中之一

> Nacos1.x将持久性作为服务元数据 存在一个服务既有临时 也有持久的情况, 在2.x之后简化

## Links

