# Transaction



在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要么全部都执行，要么全部的都不执行。

所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行，分布式事务转换为多个本地事务，然后依靠阶梯重试等方式达到最终一致性。

分布式问题的解决问题的路径可以总结为：业务规避->Base柔性事务->CP刚性事务，尽量使用最前面的方案。

## 分布式一致性分类

### 强一致性 （paxos raft zap zk）

这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。

### 弱一致性

这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。

### 最终一致性（DNS，eureka）

最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型

## CAP理论

 一个分布式系统不可能同时完全满足Consistency、Availability and Partition tolerance这三个基本需求，最多只能同时满足其中两项

### Consistency

在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。

### Availability

可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是"有限时间内"和"返回结果"。

### Partition tolerance

分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

- CA：放弃分区容错性，加强一致性和可用性，就是传统的单机数据库的选择，放弃了分布式
- AP：放弃强一致性，追求分区容错性和可用性，这是很多分布式系统设计时的选择
- CP：刚性事物，放弃可用性，追求一致性和分区容错性，通常用在金融行业要求强一致性，面临性能上线，无法满足高并发的互联网场景

## BASE

BASE是Basically Available、Soft state and Eventually consistent 三个短语的缩写。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：

- Basically Available

基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。注意，这绝不等价于系统不可用。比如： - 响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒 - 系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。

- Soft state 

软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

- Eventually consistent

最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

## 分布式事务解决方案

- 刚性事务：遵循ACID原则，强一致性
- 柔性事务：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。
  - 补偿型事务-同步(TCC，Saga)
  - 通知型事务-异步（最大努力通知型，Mq事务消息）

### 2PC

基于XA协议的两阶段提交方案 第一阶段是表决阶段，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚

### 3PC（TCC）

相比2pc，try锁的资源力度更小 事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的try接口，完成一阶段准备。之后事务协调器会根据try接口返回情况，决定调用confirm接口或者cancel接口。如果接口调用失败，会进行重试。 TCC方案让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。 当然TCC方案也有不足之处，集中表现在以下两个方面： 对应用的侵入性强。业务逻辑的每个分支都需要实现try、confirm、cancel三个操作，应用侵入性较强，改造成本高。 实现难度较大。需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口必须实现幂等。 上述原因导致TCC方案大多被研发实力较强、有迫切需求的大公司所采用。微服务倡导服务的轻量化、易部署，而TCC方案中很多事务的处理逻辑需要应用自己编码实现，复杂且开发量大。

### 基于消息的最终一致性方案（可靠消息最终一致，本地消息表）

消息一致性方案是通过消息中间件保证上、下游应用数据操作的一致性。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到消息后执行相应操作。 消息方案从本质上讲是将分布式事务转换为两个本地事务，然后依靠下游业务的重试机制达到最终一致性。基于消息的最终一致性方案对应用侵入性也很高，应用需要进行大量业务改造，成本较高。

### Seata

分布式事务框架



#### AT

对业务的无侵入，拦截sql，出现脏写就需要转人工处理 用户只需关注自己的“业务SQL”，用户的 “业务SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作

#### TCC

Try操作作为一阶段，负责资源的检查和预留，Confirm操作作为二阶段提交操作，执行真正的业务，Cancel是预留资源的取消 业务侵入性。TCC模式无AT模式的全局行锁，TCC性能会比AT模式高很多。

- 允许空回滚：try超时，分布式回滚，触发cancel。否则会不断重试
- 防悬挂控制：拒绝空回滚后的try操作，在实现TCC服务时，应当允许空回滚，但是要拒绝执行空回滚之后到来的一阶段Try请求。Cancel空回滚返回成功之前先记录该条事务xid或业务主键，标识这条记录已经回滚过.Try接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行Try 的业务操作
- 幂等控制:3个方法需保证幂等性，因为网络拥堵，超时，事务管理器可能会重试
- 业务数据可见性控制:TCC服务的一阶段Try操作会做资源的预留，在二阶段操作执行之前，如果其他事务需要读取被预留的资源数据，那么处于中间状态的业务数据该如何向用户展示，需要业务在实现时考虑清楚；通常的设计原则是“宁可不展示、少展示，也不多展示、错展示”
- 业务数据并发访问控制:TCC服务的一阶段Try操作预留资源之后，在二阶段操作执行之前，预留的资源都不会被释放；如果此时其他分布式事务修改这些业务资源，会出现分布式事务的并发问题

#### Saga

长事务，异步。原方法，补偿方法。允许空补偿，防悬挂。不具备隔离性，通过业务角度保证我方数据不出问题 一阶段提交本地数据库事务，无锁，高性能； 参与者可以采用事务驱动异步执行，高吞吐； 补偿服务即正向服务的“反向”，易于理解，易于实现

#### XA

分布式强一致性的解决方案，但性能低而使用较少

## 选举共识算法

算法

- 公链
  - pow
  - pos
  - dpos
  - ripple
- 联盟链
  - pbft
  - dbft
- 私链
  - paxos
  - raft





- 拜占庭将军问题

在存在消息丢失的不可靠信道上，试图通过消息传递的方式达到一致性是不可能的 解决方案：非对称加密技术

- Paxos协议 难于理解

应用：ZooKeeper

- ZAB原子消息广播协议，因为paxos太过于复杂，zk基于paxos实现了ZAB协议

把有最大事务ID的节点选为主，类似二阶段提交 原子广播过程： 1、leader从客户端接收一个请求 2、leader生成一个新事务，并为此事务生成一个提议-事务Id，接着把事务通知给其它follower；follower接收到此请求后，把事务ID加入一个队列里，并执行事务，最后响应leader 3、leader收到半数确定，发送提交请求；follower在提交此事务前，会判断此事务ID是不是比队列中所有的事务ID都小，如果是则提交；如果不是，等待更小的事务的提交命令。 ZAB除了事务ID，还在一个LeaderID

- Raft算法

应用：Etcd、TiDB、Consul，Kubernetes 类似民主投票，核心思想是“少数服从多数”。 跟随者（follower），候选人（candidate）和领导者（leader） 随机时钟选主，master不断给其他单元发送心跳包，如果有请求过来，心跳包里同时把数据 发过去。只解决了节点故障问题，不支持作恶节点 集群中的一个节点在某一时刻只能是这三种状态的其中一种，这三种角色是可以随着时间和条件的变化而互相转换的。 raft算法主要有两个过程：一个过程是领导者选举，另一个过程是日志复制，其中日志复制过程会分记录日志和提交数据两个阶段。raft算法支持最大的容错故障节点是（N-1）/2，其中N为集群中总的节点数量

- pbft算法

支持作恶节点，最大的容错故障节点是（N-1）/3

## 共识

如果一个节点当前的数据是 X，现在有了 add+1 的操作日志来了，那么现在的状态就是 X+1，好了，状态（X）有了，变化（操作日志）有了，这就是状态机。 共识，现实：共识就是一群人对一件或者多件事情达成一致的看法或者协议。 计算机世界：多个节点对某个数据达成一致共识。多个节点对多个数据的顺序达成一致共识 共识模型：主从同步，多数派

- POW：Proof of Work 工作量证明，用力气干活
- POS：Proof of Stake股权证明，钱生钱
- DPOS，Delegated Proof of Stake 委任权益证明， 每一个持有数字货币的人进行投票，选举各自支持的机构或是个人，得票数靠前的成为超级节点
- 总结：

POW非常强调去中心化；POS是表面上看去中心化，实则很容易中心化；DPOS 则是有一个明显的中心，通过带来部分中心，来得到效率的提升

## 复制、分片、路由

- 复制（replication）：将同一份数据拷贝到多个节点（主从master-slave方式、对等式peer-to-peer）
- 分片（sharding）：将不同数据存放在不同节点

如果想增加系统的读取性能，复制，增加slave节点即可； 如果想提升写入性能，则对数据进行分片。

- 路由：

1. 哈希分片，点查询，采用哈希函数建立Key-Partition映射（大多数KV数据库都支持此方式）

   1. Round Robbin

   俗称哈希取模算法，H(key) = hash(key) mode K（其中对物理机进行从0到K-1编号，key为某个记录的主键，H（key）为存储该数据的物理机编号）。好处是简单，缺点是增减机器要重新hash，缺乏灵活性。它实际上是将物理机和数据分片两个功能点合二为一了，因而缺乏灵活性。

   1. 虚拟桶

   membase在待存储记录和物理机之间引入了虚拟桶，形成两级映射。其中key-partition映射采用哈希函数，partition-machine采用表格管理实现。新加入机器时，只需要将原来一些虚拟桶划分给新的机器，只要修改partition-machine映射即可，具有灵活性

   1. 一致性哈希

   一致性哈希是分布式哈希表的一种实现算法，将哈希数值空间按照大小组成一个首尾相接的环状序列，对于每台机器，可以根据IP和端口号经过哈希函数映射到哈希数值空间内。通过有向环顺序查找或路由表（Finger Table）来查找。对于一致性哈希可能造成的各个节点负载不均衡的情况，可以采用虚拟节点的方式来解决。一个物理机节点虚拟成若干虚拟节点，映射到环状结构的不同位置。

2. 范围分片，范围查询

## 本地消息表-事务消息场景

![image](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>) 第一，订单系统需要创建一个新订单，订单关联的商品就是购物车中选择的那些商品。

第二，创建订单成功后，购物车系统需要把订单中的这些商品从购物车里删掉。 创建订单和清空购物车这两个数据更新操作需要保证，要么都成功，要么都失败。但是，清空购物车这个操作，它对一致性要求就没有扣减优惠券那么高，订单创建成功后，晚几秒钟再清空购物车，完全是可以接受的。只要保证经过一个小的延迟时间后，最终订单数据和购物车数据保持一致就可以了。

本地消息表非常适合解决这种分布式最终一致性的问题。我们一起来看一下，如何使用本地消息表来解决订单与购物车的数据一致性问题。

本地消息表的实现思路是这样的，订单服务在收到下单请求后，正常使用订单库的事务去更新订单的数据，并且，在执行这个数据库事务过程中，在本地记录一条消息。这个消息就是一个日志，内容就是“清空购物车”这个操作。因为这个日志是记录在本地的，这里面没有分布式的问题，那这就是一个普通的单机事务，那我们就可以让订单库的事务，来保证记录本地消息和订单库的一致性。完成这一步之后，就可以给客户端返回成功响应了。 然后，我们再用一个异步的服务，去读取刚刚记录的清空购物车的本地消息，调用购物车系统的服务清空购物车。购物车清空之后，把本地消息的状态更新成已完成就可以了。异步清空购物车这个过程中，如果操作失败了，可以通过重试来解决。最终，可以保证订单系统和购物车系统它们的数据是一致的。

创建了订单，没有清理购物车；订单没创建成功，购物车里面的商品却被清掉了。 创建订单和发送消息这两个步骤要么都操作成功，要么都操作失败，不允许一个成功而另一个失败的情况出现

事务消息适用的场景主要是那些需要异步更新数据，并且对数据实时性要求不太高的场景。比如我们在开始时提到的那个例子，在创建订单后，如果出现短暂的几秒，购物车里的商品没有被及时清空，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可以了

## 自己设计一个可靠消息平台

消息独立子系统

消息状态： 待确认，可发送，已完成

接口设计：

- 发送方 消息状态查询接口
- 接收方 保证接口幂等性
- 消息独立子系统
- 前台接口

1. 直接发送消息
2. 存储并发送消息
3. 可靠消息发送
4. 预存储消息-待确认
5. 确认并发送消息-可发送
6. 更新消息状态为-已完成

- 运营接口

1. 分页查询消息数据
2. 重发某个消息队列中的全部已死亡的消息
3. 根据MqMessageEntity重发消息
4. 将消息标记为死亡消息
5. 根据消息ID获取消息

- 定时任务接口

1. 根据消息ID删除消息
2. 根据msgObjId重发某条消息

- 定时任务

1. 消息发送方-消息状态确认后台线程：分页查询5分钟前asc-待确认消息，根据业务扩张字段调用发送方消息状态确认接口。 成功（确认并发送消息） 失败：删除消息
2. 消息接收方-消息恢复系统后台线程：分页查询5分钟前asc-可发送消息， 判断发送次数（最大6次） 根据次数对应的时间间隔（3,5,10,15,30,60）， 重新发送（根据msgObjId重发某条消息）

## 

重复发送原因

1. 发送方
2. 中间件
3. 接受方







## JTA 
Java Transaction API

 TransactionManager
    
    DataSourceTransactionManager
    JtaTransactionManager

 Resource Manager 一个或多个支持 XA 协议的资源管理器
 可为任意类型的持久化数据存储

 面向开发人员的接口为 UserTransaction （使用方法如上例所示），开发人员通常只使用此接口实现 JTA 事务管理，其定义了如下的方法：

     begin()- 开始一个分布式事务，（在后台 TransactionManager 会创建一个 Transaction 事务对象并把此对象通过 ThreadLocale 关联到当前线程上 )
     commit()- 提交事务（在后台 TransactionManager 会从当前线程下取出事务对象并把此对象所代表的事务提交）
     rollback()- 回滚事务（在后台 TransactionManager 会从当前线程下取出事务对象并把此对象所代表的事务回滚）
     getStatus()- 返回关联到当前线程的分布式事务的状态 (Status 对象里边定义了所有的事务状态，感兴趣的读者可以参考 API 文档 )
     setRollbackOnly()- 标识关联到当前线程的分布式事务将被回滚

 面向提供商的实现接口主要涉及到 TransactionManager 和 Transaction 两个对象

 Transaction 代表了一个物理意义上的事务，在开发人员调用 UserTransaction.begin() 方法时 TransactionManager 会创建一个 Transaction 事务对象（标志着事务的开始）并把此对象通过 ThreadLocale 关联到当前线程。UserTransaction 接口中的 commit()、rollback()，getStatus() 等方法都将最终委托给 Transaction 类的对应方法执行。Transaction 接口定义了如下的方法：

     commit()- 协调不同的事务资源共同完成事务的提交
     rollback()- 协调不同的事务资源共同完成事务的回滚
     setRollbackOnly()- 标识关联到当前线程的分布式事务将被回滚
     getStatus()- 返回关联到当前线程的分布式事务的状态
     enListResource(XAResource xaRes, int flag)- 将事务资源加入到当前的事务中（在上述示例中，在对数据库 A 操作时 其所代表的事务资源将被关联到当前事务中，同样，在对数据库 B 操作时其所代表的事务资源也将被关联到当前事务中）
     delistResourc(XAResource xaRes, int flag)- 将事务资源从当前事务中删除
     registerSynchronization(Synchronization sync)- 回调接口，Hibernate 等 ORM 工具都有自己的事务控制机制来保证事务， 但同时它们还需要一种回调机制以便在事务完成时得到通知从而触发一些处理工作，如清除缓存等。这就涉及到了 Transaction 的回调接口 registerSynchronization。工具可以通过此接口将回调程序注入到事务中，当事务成功提交后，回调程序将被激活。

 TransactionManager 本身并不承担实际的事务处理功能，它更多的是充当用户接口和实现接口之间的桥梁。下面列出了 TransactionManager 中定义的方法，可以看到此接口中的大部分事务方法与 UserTransaction 和 Transaction 相同。 在开发人员调用 UserTransaction.begin() 方法时 TransactionManager 会创建一个 Transaction 事务对象（标志着事务的开始）并把此对象通过 ThreadLocale 关联到当前线程上；同样 UserTransaction.commit() 会调用 TransactionManager.commit()， 方法将从当前线程下取出事务对象 Transaction 并把此对象所代表的事务提交， 即调用 Transaction.commit()

     begin()- 开始事务
     commit()- 提交事务
     rollback()- 回滚事务
     getStatus()- 返回当前事务状态
     setRollbackOnly()
     getTransaction()- 返回关联到当前线程的事务
     setTransactionTimeout(int seconds)- 设置事务超时时间
     resume(Transaction tobj)- 继续当前线程关联的事务
     suspend()- 挂起当前线程关联的事务
     
    ### CAP理论

CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：

- 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)
- 可用性(Availability) ： 每个操作都必须以可预期的响应结束
- 分区容错性(Partition tolerance) ： 即使出现单个组件无法可用，操作依然可以完成

> 具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。

上面这句话的表述，很多人都用过，是的，这是一种误解。注意CAP定律的完整表述：`Any networked shared-data system can have at most two of the three desired properties.`

CAP 定律的前提是 P，当 P 决定后才有 CA 的抉择。因此，简单粗暴地说「三选二」是有一定误导性的。

### BASE理论

在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：

- Basically Available（基本可用）
- Soft state（软状态）
- Eventually consistent（最终一致性）

BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

## 需求分析

### 功能需求

功能需求最主要的是满足分布式事务的一致性，涉及的事务组中的操作为多个写操作，当产生一个或多个写操作失败时，回滚整个事务组中的操作。

### 非功能需求

- 性能：分布式事务对系统的性能必然是有影响的，需要寻找平衡的点。
- 高可用：引入中间件或者协调者时，避免单点故障。分布式系统的高可用必然会牺牲部分一致性。
- 可扩展：降低引入的业务耦合。
- 伸缩性：系统能够弹性伸缩。

## 解决方案

### 强一致方案

X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。

> XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。

#### 2PC

二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。

![2pc](http://blueskykong.com/pic/tx-2pc.png)

- 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

- 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

- 二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

  #### 3PC

  三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。

![3pc](http://blueskykong.com/pic/tx-3pc.png)

如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的commit或rollback请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续commit。相对于两阶段提交虽然降低了同步阻塞，但仍然无法避免数据的不一致性。在分布式数据库中，如果期望达到数据的强一致性，那么服务基本没有可用性可言，这也是为什么许多分布式数据库提供了跨库事务，但也只是个摆设的原因，在实际应用中我们更多追求的是数据的弱一致性或最终一致性，为了强一致性而丢弃可用性是不可取的。

### 柔性事务

根据BASE理论，系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。

弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。 在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。但在电商等场景中，对于数据一致性的解决方法和常见的互联网系统（如 MySQL 主从同步）又有一定区别。

#### 补偿机制：TCC

TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- Try 阶段主要是对业务系统做检测及资源预留
- Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认 Confirm阶段是不会出错的。
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

![TCC](http://blueskykong.com/pic/tx-tcc.png)

**TCC与2PC协议比较**：

- 位于业务服务层而非资源层
- 没有单独的准备(Prepare)阶段，Try操作兼备资源操作与准备能力
- Try操作可以灵活选择业务资源的锁定粒度(以业务定粒度)
- 较高开发成本

#### 本地消息表

类似于可靠消息方案。

![本地消息表](http://blueskykong.com/pic/localmsg.png)

消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

这种方案遵循BASE理论，采用的是最终一致性，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。

优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。

缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

#### 事务消息

![转账流程](http://blueskykong.com/pic/tx-transfer.png)

RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。

如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。

如果endTransaction方法执行失败，数据没有发送到broker，导致事务消息的 状态更新失败，broker会有回查线程定时（默认1分钟）扫描每个存储事务状态的表格文件，如果是已经提交或者回滚的消息直接跳过，如果是prepared状态则会向Producer发起CheckTransaction请求，Producer会调用DefaultMQProducerImpl.checkTransactionState()方法来处理broker的定时回调请求，而checkTransactionState会调用我们的事务设置的决断方法来决定是回滚事务还是继续执行，最后调用endTransactionOneway让broker来更新消息的最终状态。

- 消费失败
  解决超时问题的思路就是一直重试，直到消费端消费消息成功
- 消费超时
  消费失败怎么办？阿里提供给我们的解决方法是：人工解决。大家可以考虑一下，按照事务的流程，因为某种原因Smith加款失败，那么需要回滚整个流程。如果消息系统要实现这个回滚流程的话，系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比消费失败的概率大很多。这也是RocketMQ目前暂时没有解决这个问题的原因，在设计实现消息系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，这也是大家在解决疑难问题时需要多多思考的地方。

## Lottor介绍

Lottor用于解决微服务架构下分布式事务的问题，基于可靠性消息事务模型实现。

### Lottor的结构

Lottor由三部分组成：

- Lottor Server
- Lottor Client
- Lottor UI

Lottor服务器与客户端之间的通信使用的高性能通信框架：Netty。所有的客户端（生产端和消费端）都会与服务器保持长连接。Lottor UI用于展示系统中的事务组详细信息，包括预提交的事务组、消费失败的事务消息，并支持页面操作失败的消息（如补偿或重试）。

![Lottor的设计](http://blueskykong.com/pic/lottor-arche.jpg)

### 功能介绍

生产方分为三步：

- 预发送消息，首先会将消费方的事务组（一条或多条事务消息）组装好，并发送到Lottor Server，事务消息的状态为`预发送`。
- 执行本地事务：预发送之后，将会执行本地事务。
- 发送确认消息：根据本地事务的执行结果，异步发送确认消息。如果本地事务出现异常，回滚本地事务，并将异常信息捕捉一起发送到Lottor Server。本地也会持久化该状态（定期删除）。

Lottor Server：

- 接收预提交消息：收到预提交消息，将事务组中的事务消息分别保存，状态为`pre-commit`。
- 接收确认消息：状态为confirm，将更改相应的事务组状态，并将消息发送到对应的消费方（MQ异步实现），并标记事务消息的状态为`unconsumed`。否则，回滚状态只会修改事务组状态（定期删除）。
- 回查预发送消息的状态：状态为`pre-commit`的事务组消息，Lottor Server将会定期回查生产方。
- 回查事务消息的状态：状态为`unconsumed`（一般4h），Lottor Server将会定期回查消费方。

消费方：

- 接收事务消息：订阅相关的主题，消费完成之后，将会异步发送ACK给Lottor Server，消费失败会将异常返回给Lottor Server。本地也会持久化消费的状态（定期删除）。

Lottor 客户端的持久化，提供了SPI接口，可通过配置动态指定。目前支持：JDBC、Redis、MongoDB和文件系统。

### 告警机制及消费补偿

这里所说的告警机制及消费补偿是针对消费端，可靠消息方案是保证了事务消息一定能够到达消费方，但是消费方可能因为某些原因而无法成功消费，有些消费异常是可以通过重试解决的，而有些异常是需要告警之后人工干预的。比如消费方暂时不可用，或者是多个消费方消费的顺序问题，可以通过定时的重试机制完成。而如果是由于生产方发送的事务消息出错（参数构造错误），此时消费方已经提交了本地事务组，所以是无法通过重试实现成功消费，导致需要告警，人为解决脏数据的问题。

### 适用场景

对于分布式系统的吞吐量有较高的要求，以及能够满足最终一致性的场景。如上面提到的告警机制及消费补偿，分布式事务是对微服务系统的完善，但是并不能完全保证一致性，可能需要通过告警等手段解决极端问题产生的不一致情况。