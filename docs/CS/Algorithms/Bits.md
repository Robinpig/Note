## Introduction

**位运算（Bit Operation）**：计算机内部所有数据均以「二进制（Binary）」形式存储
位运算是直接对二进制位进行操作的运算方式，能够极大提升程序的执行效率



## 应用

### 判断整数奇偶

判断一个整数的奇偶性，可以利用其二进制表示的最低位。
偶数的二进制最低位为 0，奇数的最低位为 1。因此，通过将该数与 1 进行按位与运算即可快速判断



### 交换两个整数

通过按位异或运算，可以无需临时变量实现两个整数的交换（仅适用于整数类型）

```
a, b = 10, 20
a ^= b
b ^= a
a ^= b
```



### 判断某数是否为 2 的幂次方

判断一个数 X 是否为 2 的幂，可以利用位运算：只需判断 `X & (X - 1) == 0` 是否成立



### 位运算的常用操作总结

| 序号 | 操作描述                 | 位运算表达式                    | 示例                                                  |
| :--: | :----------------------- | :------------------------------ | :---------------------------------------------------- |
|  1   | 将最低位的 1 置为 0      | `x & (x - 1)`                   | `100101000 -> 100100000`                              |
|  2   | 保留最右侧的 1，其余清零 | `x & -x` 或 `x & (x ^ (x - 1))` | `100101000 -> 1000`                                   |
|  3   | 去掉最后一位             | `x >> 1`                        | `101101 -> 10110`                                     |
|  4   | 取右数第 k位             | `(x >> (k - 1)) & 1`            | `1101101 -> 1, k = 4`                                 |
|  5   | 取末尾 k位               | `x & ((1 << k) - 1)`            | `1101101 -> 101, k = 3`； `1101101 -> 1101, k = 4`    |
|  6   | 只保留右边连续的 1       | `(x ^ (x + 1)) >> 1`            | `100101111 -> 1111`                                   |
|  7   | 右数第 k位取反           | `x ^ (1 << (k - 1))`            | `101001 -> 101101, k = 3`                             |
|  8   | 在最后加一个 0           | `x << 1`                        | `101101 -> 1011010`                                   |
|  9   | 在最后加一个 1           | `(x << 1) + 1`                  | `101101 -> 1011011`                                   |
|  10  | 把右数第 k位变成 0       | `x & ~(1 << (k - 1))`           | `101101 -> 101001, k = 3`                             |
|  11  | 把右数第 k 位变成 1      | `x | (1 << (k - 1))`            | `101001 -> 101101, k = 3`                             |
|  12  | 把右边起第一个 0 变成 1  | `x | (x + 1)`                   | `100101111 -> 100111111`                              |
|  13  | 把右边连续的 0 变成 1    | `x | (x - 1)`                   | `11011000 -> 11011111`                                |
|  14  | 把右边连续的 1 变成 0    | `x & (x + 1)`                   | `100101111 -> 100100000`                              |
|  15  | 把最后一位变成 0         | `x & ~1`                        | `101101 -> 101100`                                    |
|  16  | 把最后一位变成 1         | `x | 1`                         | `101100 -> 101101`                                    |
|  17  | 把末尾 k位变成 1         | `x | ((1 << k) - 1)`            | `101001 -> 101111, k = 4`                             |
|  18  | 末尾 k 位取反            | `x ^ ((1 << k) - 1)`            | `101101 -> 101100, k = 1`； `101001 -> 100110, k = 4` |



## Links

- [Algorithm Analysis](/docs/CS/Algorithms/Algorithms.md?id=algorithm-analysis)

## References

1. [Effective Programming in C and Unix - Lecture 19 Bit Operations ](https://www.cs.cmu.edu/~guna/15-123S11/Lectures/Lecture19.pdf)

