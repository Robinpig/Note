## Introduction

字符串，就是由字符连接而成的序列
常见的字符串问题包括字符串匹配问题、子串相关问题、前缀/后缀相关问题、回文串相关问题、子序列相关问题等



## 基础概念

一个 **字符串** S 是将 n 个字符顺次排列形成的序列，n 称为 S 的长度，表示为 |𝑆|![|S|]。

如果字符串下标从 1 开始计算，S 的第 i 个字符表示为 𝑆[𝑖]![S[i]]；

如果字符串下标从 0![0] 开始计算，S 的第 i 个字符表示为 𝑆[𝑖 −1]



字符串 S 的 **子串** 𝑆[𝑖..𝑗]，𝑖 ≤𝑗![S[i..j]，i≤j]，表示 S 串中从 i 到 𝑗![j] 这一段，也就是顺次排列 𝑆[𝑖],𝑆[𝑖 +1],…,𝑆[𝑗]![S[i],S[i+1],\ldots,S[j]] 形成的字符串。

有时也会用 𝑆[𝑖..𝑗]![S[i..j]]，𝑖 >𝑗![i>j] 来表示空串



字符串 S 的 **子序列** 是从 S 中将若干元素提取出来并不改变相对位置形成的序列，即 𝑆[𝑝1],𝑆[𝑝2],…,𝑆[𝑝𝑘]![S[p_1],S[p_2],\ldots,S[p_k]]，1 ≤𝑝1 <𝑝2 <⋯ <𝑝𝑘 ≤|𝑆|



**回文串** 是正着写和倒着写相同的字符串，即满足 ∀1 ≤𝑖 ≤|𝑠|,𝑠[𝑖] =𝑠[|𝑠| +1 −𝑖]![\forall 1\le i\le|s|, s[i]=s[|s|+1-i]] 的 𝑠



**汉明距离** 是两个等长字符串之间的距离，它表示两个长度相同的字符串对应位字符不同的数量。

我们可以简单的认为对两个串进行异或运算，结果为 1 的数量就是两个串的汉明距离



字符串的存储

- 使用 `char` 数组存储，用空字符 `\0` 表示字符串的结尾（C 风格字符串）。
- 使用 C++ 标准库提供的 [`string` 类](https://oi-wiki.org/lang/csl/string/)。
- 字符串常量可以用字符串字面量（用双引号括起来的字符串）表示





## String match



字符串匹配问题又称模式匹配（pattern matching）。该问题可以概括为「给定字符串 S 和 𝑇![T]，在主串 S 中寻找子串 𝑇![T]」。字符 𝑇![T] 称为模式串 (pattern)



类型

- 单串匹配：给定一个模式串和一个待匹配串，找出前者在后者中的所有位置。
- 多串匹配：给定多个模式串和一个待匹配串，找出这些模式串在后者中的所有位置。
  - 出现多个待匹配串时，将它们直接连起来便可作为一个待匹配串处理。
  - 可以直接当做单串匹配，但是效率不够高。
- 其他类型：例如匹配一个串的任意后缀，匹配多个串的任意后缀……



## Hash

我们定义一个把字符串映射到整数的函数 𝑓![f]，这个 𝑓![f] 称为是 Hash 函数。

我们希望这个函数 𝑓![f] 可以方便地帮我们判断两个字符串是否相等

哈希函数需要实现下面两条：

1. 在 Hash 函数值不一样的时候，两个字符串一定不一样；

2. 在 Hash 函数值一样的时候，两个字符串不一定一样（但有大概率一样，且我们当然希望它们总是一样的）。

   我们将 Hash 函数值一样但原字符串不一样的现象称为哈希碰撞





## Trie

字典树，英文名 trie。顾名思义，就是一个像字典一样的树

字典树最基础的应用——查找一个字符串是否在「字典」中出现过





## 回文树

 回文树（EER Tree，Palindromic Tree，也被称为回文自动机）是一种可以存储一个串中所有回文子串的高效数据结构。最初由 Mikhail Rubinchik 和 Arseny M. Shur 在 2015 年发表。它的灵感来源于后缀树等字符串后缀数据结构，使用回文树可以简单高效地解决一系列涉及回文串的问题











## Links

