## Introduction



## Data Structures
An abstract data type (ADT) is a set of operations. 
Abstract data types are mathematical abstractions; nowhere in an ADT's definition is there any mention of how the set of operations is implemented. 
This can be viewed as an extension of modular design.


- [hash](/docs/CS/Algorithms/hash.md)

## The List ADT

array
- [Linked List](/docs/CS/Algorithms/linked-list.md)

ADT
  
- [List](/docs/CS/Algorithms/list.md)
- [stack](/docs/CS/Algorithms/stack.md)
- [queue](/docs/CS/Algorithms/queue.md)

### Tree
- [Trie](/docs/CS/Algorithms/Trie.md)
- [BinaryTree](/docs/CS/Algorithms/BinaryTree.md)
- [Red-Black Tree](/docs/CS/Algorithms/Red-Black-Tree.md)

### Page Replacement Algorithms
- [LRU](/docs/CS/Algorithms/LRU.md)

## Algorithm Analysis

In computer science, the analysis of algorithms is the process of finding the computational complexity of algorithms â€“ the amount of time, storage, or other resources needed to execute them.
Usually, this involves determining a function that relates the length of an algorithm's input to the number of steps it takes (its time complexity) or the number of storage locations it uses (its space complexity).
An algorithm is said to be efficient when this function's values are small, or grow slowly compared to a growth in the size of the input. 
Different inputs of the same length may cause the algorithm to have different behavior, so best, worst and average case descriptions might all be of practical interest. 
When not otherwise specified, the function describing the performance of an algorithm is usually an upper bound, determined from the worst case inputs to the algorithm.

In theoretical analysis of algorithms it is common to estimate their complexity in the asymptotic sense, i.e., to estimate the complexity function for arbitrarily large input. 
Big O notation, Big-omega notation and Big-theta notation are used to this end.

Exact (not asymptotic) measures of efficiency can sometimes be computed but they usually require certain assumptions concerning the particular implementation of the algorithm, called model of computation. 
A model of computation may be defined in terms of an abstract computer, e.g., Turing machine, and/or by postulating that certain operations are executed in unit time.

### Model

This model clearly has some weaknesses. Obviously, in real life, not all operations take exactly the same time. In particular, in our model one disk read counts the same as an addition, even though the addition is typically several orders of magnitude faster. Also, by assuming infinite memory, we never worry about page faulting, which can be a real


Euclid's algorithm is for computing the greatest common divisor. 
The greatest common divisor (gcd) of two integers is the largest integer that divides both.

### Advanced Design and Analysis Techniques
- [Dynamic Programming](/docs/CS/Algorithms/DP.md)
- [Greedy Programming](/docs/CS/Algorithms/Greedy.md)





## Sorting and Order Statistics

- [Sort](/docs/CS/Algorithms/Sort.md)

### Heapsort

### Quicksort

### Sorting in Linear Time

### Medians and Order Statistics

Divide-and-Conquer

## Data Structures


### Binary Search Trees

### Red-Black Trees

AVL Tree

## Advanced Design and Analysis Techniques

### Dynamic Programming

### Greedy Algorithms

### Amortized Analysis


## Advanced Data Structures

### B-Trees

### Fibonacci Heaps


## Graph Algorithms


## Advanced Design and Analysis Techniques

### Dynamic Programming

### Greedy Algorithms

### Amortized Analysis


## Advanced Data Structures

### B-Trees

### Fibonacci Heaps


## Graph Algorithms


## References
1. Introduction to Algorithms Third Edition
2. Introduction to The Design and Analysis of Algorithms Third Edition
3. Algorithms Fourth Edition