## Introduction



## Problem

### 缓存雪崩

缓存雪崩-缓存数据同一时刻大规模不可用(失效或或更新)

可能原因:

- 设置缓存时，key都采用了相同expire
- 更新策略
- 数据热点
- 缓存服务宕机

解决方案

- 更新策略在时间上做到比较均匀
- 使用的热数据尽量分散到不同的机器上
- 多台机器做主从复制或者多副本，实现高可用
- 实现熔断限流机制，对系统进行负载能力控制
- 原有失效时间基础上增加一个随机值，降低过期时间重复率

### 缓存穿透

缓存穿透-大量并发查询**不存在的KEY**，直接将压力透传到数据库

原因

- 缓存未区分KEY不存在和查询到一个空值 被查询绕过

解决方案

- 缓存空值的KEY，占用空间大
- Bloom过滤器或RoaringBitmap 判断KEY是否存在

- 完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。

### 缓存击穿

缓存击穿-某KEY失效时，正好有大量并发请求访问该KEY对数据库造成压力

但如下问题若同时出现，可能对系统致命：

- 为热点key，访问量非常大
- 缓存的构建是需要时间（可能是个复杂过程，例如复杂SQL、多次I/O、多个接口依赖）

于是就会导致： 在缓存失效瞬间，有大量线程构建缓存，导致后端负载加剧，甚至可能让系统崩溃。

解决方案

- 限制处理线程的数量，即KEY的更新操作添加全局互斥锁
- 使用异步线程负责维护缓存的数据，定期或根据条件触发更新，这样就不会触发更新
- 限流 如使用 hystrix 或者 sentinel

## 缓存更新/数据一致性

**Cache Aside Pattern**

**Read Through Pattern**

**Write Through Pattern**

**Write Behind Caching Pattern**