# G1





-XX:+UseG1GC in JDK9 default

-XX:ParallelGCThreads

Default  2048 Region

use -XX:+G1HeapRegionSize could define but suggest default



Young default 5% of heap size and suggest less than 60%

-XX:G1NewSizePercent -XX:G1MaxNewSizePercent



Eden : survivor1: survivor2 = 8: 1: 1 still

Humongous over half of region size





可预测停顿 -XX:MaxGCPauseMillis



GC

Young GC

Mixed GC

Full GC



-XX:InitiatingHeapOccupancyPercent





采⽤标记-整理算法
G1收集器的特短：
并⾏与并发
分代收集（与其他收集器⼀样）
空间整理（标记-整理算法）
可预测的停顿

如果不计算维护Remembered Set的操作，G1收集器的运作⼤致可划分为以下⼏个步骤：
初始标记（Initial Marking）
并发标记（Concurrent Marking）
最终标记（Final Marking）
筛选回收（Live Data Counting and Evacuation）

Java 技术体系中所提倡的⾃动内存管理最终可以归结为⾃动化地解决两个问题：给对象分配内存以及回收
分配对对象的内存。
⼤多数情况下，对象在新⽣代Eden区中分配。当Eden区没有⾜够空间进⾏分配时，虚拟机将发起⼀次
Minor Gc.
所谓⼤对象是指，需要⼤量连续内存空间的Java对象，最典型的⼤对象就是字节数组等。
G1收集器
内存分配与回收策略
对象优先在Eden分配
⼤对象直接进⼊⽼年代
⻓期存活的对象将进⼊⽼年代

空间分配担保

在发⽣Minor Gc之前，虚拟机会先检查⽼年代最⼤可⽤的连续空间是否⼤于新⽣代所有对象的总空间，如
果这个条件成⽴，那么Minnor Gc可⽤确保是安全的。如果不成⽴，则虚拟机会查看
HandlePromotyionFailure设置值是否允许担保失败。如果允许，那么会继续检查⽼年代最⼤空间是否⼤
于历次晋升到⽼年代对象的平均⼤⼩，如果⼤于，将尝试⼀次 Minnor Gc；如果⼩于，或者
HandlePromotyionFailure设置不允许冒险，那么这时要进⾏⼀次Full Gc