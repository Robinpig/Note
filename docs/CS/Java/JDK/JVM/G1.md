# G1

The Garbage-First (G1) garbage collector is a server-style garbage collector, **targeted for multiprocessor machines with large memories**. `It attempts to meet garbage collection (GC) pause time goals with high probability while achieving high throughput.` Whole-heap operations, such as global marking, are performed concurrently with the application threads. This prevents interruptions proportional to heap or live-data size.


The first focus of G1 is to provide a solution for users running applications that require large heaps with limited GC latency. **This means heap sizes of around 6 GB or larger, and a stable and predictable pause time below 0.5 seconds.**

Applications running today with either the CMS or the with parallel compaction would benefit from switching to G1 if the application has one or more of the following traits.
- More than 50% of the Java heap is occupied with live data.
- The rate of object allocation rate or promotion varies significantly.
- The application is experiencing undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second).

G1 is planned as the long-term replacement for the Concurrent Mark-Sweep Collector (CMS). Comparing G1 with CMS reveals differences that make G1 a better solution. 
- One difference is that G1 is a compacting collector. Also, G1 offers more predictable garbage collection pauses than the CMS collector, and allows users to specify desired pause targets.
- As with CMS, G1 is designed for applications that require shorter GC pauses.



-XX:+UseG1GC in JDK9 default

-XX:ParallelGCThreads

Default  2048 Region

use -XX:+G1HeapRegionSize could define but suggest default



Young default 5% of heap size and suggest less than 60%

-XX:G1NewSizePercent -XX:G1MaxNewSizePercent



Eden : survivor1: survivor2 = 8: 1: 1 still

Humongous over half of region size





可预测停顿 -XX:MaxGCPauseMillis



GC

Young GC

Mixed GC

Full GC



-XX:InitiatingHeapOccupancyPercent





全局采⽤标记-整理算法

局部是copy 

G1收集器的特短：
并⾏与并发
分代收集（与其他收集器⼀样）
空间整理（标记-整理算法）
可预测的停顿

如果不计算维护Remembered Set的操作，G1收集器的运作⼤致可划分为以下⼏个步骤：

- Init Mark
- Concurrent Mark
- Finish Mark
- Compact - Smaller, adjustable, but still a pause

Young GC all using copy and STW(smaller, adjustable).



初始标记（Initial Marking）
并发标记（Concurrent Marking）
最终标记（Final Marking）
筛选回收（Live Data Counting and Evacuation）

Java 技术体系中所提倡的⾃动内存管理最终可以归结为⾃动化地解决两个问题：给对象分配内存以及回收
分配对对象的内存。
⼤多数情况下，对象在新⽣代Eden区中分配。当Eden区没有⾜够空间进⾏分配时，虚拟机将发起⼀次
Minor Gc.
所谓⼤对象是指，需要⼤量连续内存空间的Java对象，最典型的⼤对象就是字节数组等。
G1收集器
内存分配与回收策略
对象优先在Eden分配
⼤对象直接进⼊⽼年代
⻓期存活的对象将进⼊⽼年代

空间分配担保

在发⽣Minor Gc之前，虚拟机会先检查⽼年代最⼤可⽤的连续空间是否⼤于新⽣代所有对象的总空间，如
果这个条件成⽴，那么Minnor Gc可⽤确保是安全的。如果不成⽴，则虚拟机会查看
HandlePromotyionFailure设置值是否允许担保失败。如果允许，那么会继续检查⽼年代最⼤空间是否⼤
于历次晋升到⽼年代对象的平均⼤⼩，如果⼤于，将尝试⼀次 Minnor Gc；如果⼩于，或者
HandlePromotyionFailure设置不允许冒险，那么这时要进⾏⼀次Full Gc

## parallel FullGC
The current implementation of the full GC for G1 uses a single threaded mark-sweep-compact algorithm.
[JEP 307: Parallel Full GC for G1](https://openjdk.java.net/jeps/307)

-XX:ParallelGCThreads


```cpp
// g1FullCollector.cpp
void G1FullCollector::collect() {
  phase1_mark_live_objects();
  verify_after_marking();

  // Don't add any more derived pointers during later phases
  deactivate_derived_pointers();

  phase2_prepare_compaction();

  phase3_adjust_pointers();

  phase4_do_compaction();
}
```


## References
1. [The Garbage-First Garbage Collector](http://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html)
2. [Garbage-First Garbage Collector Tuning](http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html)