# CMS



CMS（Concurrent Mark Sweep)收集器是⼀种以获取最短回收停顿时间为⽬标的收集器。
初始标记
并发标记
重新标记
并发清除



其中，初始标记、重新标记这两个步骤仍然需要“stop the world”。初始标记仅仅只是标记⼀下GC roots
能够关联到的对象，速度很快。并发标记是进⾏GC roots Tracing过程。重新标记，修正并发标记期间⽤
户程序就⾏运⾏⽽导致标记产⽣变动的那⼀部分对象。
三个缺点：

1. 对CPU资源⾮常敏感
2. CMS收集器⽆法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败⽽
   导致另⼀次Full GC的产⽣。由于CMS并发清理阶段⽤户线程还在运⾏着，伴随程序运⾏⾃然就还会有
   新的垃圾不断产⽣，这⼀部分垃圾出现在标记过程之后，CMS⽆法在当次收集中处理掉它们，只好留
   待下⼀次GC时再清理掉。这⼀部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段⽤户线程还需要
   运⾏，那也就还需要预留有⾜够的内存空间给⽤户线程使⽤，因此CMS收集器不能像其他收集器那样
   等到⽼年代⼏乎完全被填满了再进⾏收集，需要预留⼀部分空间提供并发收集时的程序运作使⽤。在
   JDK1.5的默认设置下，CMS收集器当⽼年代使⽤了68%的空间后就会被激活，这是⼀个偏保守的设
   置，如果在应⽤中⽼年代增⻓不是太快，可以适当调⾼参数-XX：CMSInitiatingOccupancyFraction
   的值来提⾼触发百分⽐，以便降低内存回收次数从⽽获取更好的性能，在JDK 1.6中，CMS收集器的启
   动阈值已经提升⾄92%。要是CMS运⾏期间预留的内存⽆法满⾜程序需要，就会出现⼀
   次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启⽤Serial Old收集器来重新
   进⾏⽼年代的垃圾收集，这样停顿时间就很⻓了
3. CMS 是标记清除算法，会有⼤量的空间碎⽚，但是当⽆法找到⾜够⼤的连续空间来分配当前对象，不
   得不提前触发⼀次Full GC



