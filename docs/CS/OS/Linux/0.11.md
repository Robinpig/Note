## Introduction

Linux-0.11版本在发布时包括以下文件:

| File             | Desc                                                     |
| ---------------- | -------------------------------------------------------- |
| bootimage.Z      | 具有美国键盘代码的压缩启动映像文件                       |
| rootimage.Z      | 以 1200kB 压缩的根文件系统映像文件                       |
| linux-0.11.tar.Z | 内核源代码文件。大小为 94KB，展开后也仅有 325KB          |
| as86.tar.Z       | Bruce Evans'二进制执行文件。是 16 位的汇编程序和装入程序 |
| INSTALL-0.11     | 更新过的安装信息文件                                     |



as86 和ld86 是由Bruce Evans 编写的Intel 8086 汇编编译程序和连接程序。它完全是一个8086 的

汇编编译器，但却可以为386 处理器编制32 位的代码。Linux 使用它仅仅是为了创建16 位的启动扇区

(bootsector)代码和setup 二进制执行代码。该编译器的语法与GNU 的汇编编译器的语法是不兼容的，但

近似于Intel 的汇编语言语法（如操作数的次序相反等）



System.map 文件用于存放内核符号表信息。符号表是所有符号及其对应地址的一个列表。随着每次内

核的编译，就会产生一个新的对应System.map 文件。当内核运行出错时，通过System.map 文件中的符号

表解析，就可以查到一个地址值对应的变量名，或反之



Linux 的最最前面部分是用8086 汇编语言编写的(boot/bootsect.s)，它将由BIOS 读入到内存0x7C00

处，当它被执行时就会把自己移到绝对地址0x90000 处，并将启动设备(boot/setup.s)的下2kB 字节的代

码读入内存0x90200 处，而内核的其它部分（system 模块）则被读入到从地址0x10000 开始处，因为当时

system 模块的长度不会超过0x80000（即512KB），所以它不会覆盖在0x90000 处开始的bootsect 和setup

模块。



启动部分识别主机的某些特性以及vga 卡的类型。如果需要，它会要求用户为控制台选择显示模式。

然后将整个系统从地址0x10000 移至0x0000 处，进入保护模式并跳转至系统的余下部分（在0x0000 处）。

此时所有32 位运行方式的设置启动被完成: IDT、GDT 以及LDT 被加载，处理器和协处理器也已确认，分

页工作也设置好了；最终调用init/main.c 中的main()程序。上述操作的源代码是在boot/head.S 中的



boot/目录中的三个汇编代码文件却使用了两种语法格式。Bootsect.s 和setup.s 采用近似于Intel 的汇编语言

语法，需要使用Intel 8086 汇编编译器和连接器as86 和ld86，而head.s 则使用GNU 的汇编程序格式，

需要用GNU 的as 进行编译。这是一种AT&T 语法的汇编语言程序



bootsect.s 代码是磁盘引导块程序，驻留在磁盘的第一个扇区中（引导扇区，0 磁道（柱面），0 磁头，

第1 个扇区）。在PC 机加电ROM BIOS 自检后，引导扇区由BIOS 加载到内存0x7C00 处，然后将自己移动

到内存0x90000 处。该程序的主要作用是首先将setup 模块（由setup.s 编译成）从磁盘加载到内存紧接

着bootsect 的后面位置（0x90200）,然后利用BIOS 中断0x13 取磁盘参数表中当前启动引导盘的参数，

接着在屏幕上显示“Loading system...”字符串。再者将system 模块从磁盘上加载到内存0x10000 开始

的地方。随后确定根文件系统的设备号，若没有指定，则根据所保存的引导盘的每磁道扇区数判别出盘的

类型和种类（是1.44M A 盘？）并保存其设备号于root_dev(引导块的0x508 地址处)，最后长跳转到setup

程序的开始处（0x90200）执行setup 程



setup 程序的作用主要是利用ROM BIOS 中断读取机器系统数据，并将这些数据保存到0x90000 开始的

位置（覆盖掉了bootsect 程序所在的地方），



然后setup 程序将system 模块从0x10000-0x8ffff（当时认为内核系统模块system 的长度不会超过

此值：512KB）整块向下移动到内存绝对地址0x00000 处。接下来加载中断描述符表寄存器(idtr)和全局

描述符表寄存器(gdtr)，开启A20 地址线，重新设置两个中断控制芯片8259A，将硬件中断号重新设置为

0x20 - 0x2f。最后设置CPU 的控制寄存器CR0（也称机器状态字），从而进入32 位保护模式运行，并跳转

到位于system 模块最前面部分的head.s 程序继续运行





head.s 程序在被编译后，会被连接成system模块的最前面开始部分，这也就是为什么称其为头部(head)

程序的原因。从这里开始，内核完全都是在保护模式下运行了。heads.s 汇编程序与前面的语法格式不同，

它采用的是AT&T 的汇编语言格式，并且需要使用GNU 的gas 和gld 进行编译连接。因此请注意代码中付

值的方向是从左到右。

这段程序实际上处于内存绝对地址0 处开始的地方。这个程序的功能比较单一。首先是加载各个数据

段寄存器，重新设置中断描述符表，共256 项，并使各个表项均指向一个只报错误的哑中断程序。然后重

新设置全局描述符表。接着使用物理地址0 与1M 开始处的内容相比较的方法，检测A20 地址线是否真的

开启（如果没有开启，则在访问高于1Mb 物理内存地址时CPU 实际只会访问（IP MOD 1Mb）地址处的内容），

如果检测下来发现没有开启则进入死循环。然后测试PC 机是否含有数学协处理器芯片，并在控制寄存器

CR0 中置相应的标志位。接着设置分页处理机制，将页目录表放在绝对物理地址0 开始处，紧随后面放置

4 个页表（可寻址16MB 内存），并分别设置它们的表项。最后利用返回指令将预先放置在堆栈中/init/main.c

程序的地址弹出，去运行main()程序



系统调用的实现基础，其实就是两条汇编指令，分别是syscall和sysret。 

syscall使执行逻辑从用户态切换到内核态，在进入到内核态之后，cpu会从 MSR_LSTAR 寄存器中，获取处理系统调用内核代码的起始地址，即上面的 entry_SYSCALL_64。

在执行 entry_SYSCALL_64 函数时，内核代码会根据约定，先从rax寄存器中获取想要执行的系统调用的编号，然后根据该编号从sys_call_table数组中找到对应的系统调用函数。

接着，从 rdi, rsi, rdx, r10, r8, r9 寄存器中获取该系统调用函数所需的参数，然后调用该函数，把这些参数传入其中。

在系统调用函数执行完毕之后，执行结果会被放到rax寄存器中。

最后，执行sysret汇编指令，从内核态切换回用户态，用户程序继续执行。

如果用户程序需要该系统调用的返回结果，则从rax中获取。





## Links

- [Linux](/docs/CS/OS/Linux/Linux.md)