## Introduction

notify诞生于2007年，是伴随着淘宝交易系统进入分布式时代产生的。主要用于核心交易链路的异步解耦，以缩短了下单流程的RT，提高了电商业务的扩展能力。
目前电商核心业务领域对象包括收藏夹、购物车、订单、用户、商品、物流单、资金的状态变更都会产生notify消息，很多电商下游和周边系统都可以通过订阅这些消息来透明的构建围绕自身的特色业务
以下是notify支撑的核心交易业务图，可以认为notify百分之90以上的消息都是来自交易相关业务

除了实现基本的消息收发功能之外，相比于其他消息中间件，notify有着自身的特点，主要是事务消息、header过滤订阅和实时推送。
这两个功能是电商链路的刚需，解决了异步架构的最终一致性问题、也解决了电商下游细分业务领域的消息过滤需求。
先说事务消息，它实现了消息生产者本地事务和消息发送的原子性。以订单创建为例，tp先创建订单（本地事务），再发订单创建的消息，如果订单创建成功，消息没发出去，那么下游所有系统都无法感知这个事件，会出现脏数据；
如果先发订单创建消息，再创建订单，也有可能出现订单创建失败了，但是下游系统都认为此订单已经创建，也会出现脏数据。而事务消息的作用就是用于保障订单创建成功和消息发送成功的最终一致，交易上下游的状态也才能达到最终一致。
再说header过滤订阅，它解决的是消息精细过滤问题。今年双十一峰值时刻TRADE（这是交易订单对应的notify topic）的秒级消息量是140w，
而订阅TRADE的下游应用有600个，如果这600个应用照单全收所有的TRADE消息，对notify server来说需要每秒推送8.5亿消息，TRADE消息体大小为6k，
notify的出口带宽会达到4894GByte，这会对notify服务器和机房带宽产生巨大的压力。对于订阅者应用而言，要处理每秒140w的6k大消息，每个应用也都要准备几百台的机器才能扛得住，
会造成极大的机器浪费。有了header过滤订阅，notifyserver会按照订阅者设定的规则，只给每个应用推送它所需要的消息，例如某个类目、某个卖家、某个垂直市场的，甚至可以做到多种消息属性的与或非组合条件。
一个系统的架构倾向往往和他所要满足的业务场景有关，为了方便实现事务消息和属性过滤，notify采用了kv的存储范式来维护消息状态、以及堆内即时过滤推送的消费模式。




普通消息的处理流程如下，当notify收到消息后，先进行持久化，在kv存储增加一条记录，然后ack给生产者；持久化后执行exchange，
这一步会对消费者Subscription的属性过滤规则进行计算，得到目标消费者id集合，找到消费者channel直接push。push完后，内存中维护callback等待消费者ack（成功或者失败）
如果没有ack，callback默认等待5秒，作为消费超时处理。最多等待5秒后，callback收集到所有ack，如果全部成功，那么直接删除消息记录；如果部分失败，对消息记录进行修改，主要是修改fail target字段，记录失败消费者id。
notify会有后台任务扫描未删除记录，重新投递给失败的消费者id，再次执行4、5、6步骤


对于事务消息，区别之处在于消息生产环节。生产者先发送half消息，当notify收到half消息后，先进行持久化，在kv存储增加一条half（即commited字段为false）记录，然后ack给生产者，此时并不会触发推送消费者事件。
生产者half发送成功后，执行本地事务，事务执行成功后，发送commit请求。notify收到commit请求后，讲消息的commited字段更新为true，然后就立马执行推送消费者的流程，消费相关逻辑和普通消息无异。



```java


```





```java

```







## Links

- [RocketMQ](/docs/CS/MQ/RocketMQ/RocketMQ.md)